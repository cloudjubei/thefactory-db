{
  "id": "d37e5f1f-63a0-486d-a0c6-28642f72d243",
  "status": "-",
  "title": "On-demand ephemeral PostgreSQL (pgvector) lifecycle: managed container or external URL",
  "description": "Goal\nProvide a programmatic, on-demand PostgreSQL with pgvector lifecycle so clients can call createDatabase() to start a fresh DB and destroyDatabase() to fully tear it down. Keep openDatabase() for users who already manage their DB.\n\nOperating modes (definitive)\n- Managed (default): If no connectionString is supplied, start a fresh Postgres+pgvector container via Testcontainers using image 'pgvector/pgvector:pg16'. Wait until ready, build a connection string, and initialize the schema via openDatabase(). On destroyDatabase(), stop and remove the container. No reuse, no persistence.\n- External: If a connectionString is supplied, treat it as server access with privileges to CREATE DATABASE and CREATE EXTENSION vector. On createDatabase(), generate a temporary database name (e.g. 'tfdb_<random>'), create it (connecting to the 'postgres' DB for admin ops), connect to the new DB, and run schema init. On destroyDatabase(), DROP the temporary database. No truncation or schema-only cleanup; the entire database is removed.\n\nAdditional API: reusable database provisioning (opt-in)\n- For clients who want this package to fully provision a long-lived local database and reuse it:\n  - createReusableDatabase(options?: { logLevel?: LogLevel }): Promise<{ connectionString: string; created: boolean }>\n  - Behavior: Managed persistent instance using Docker and image 'pgvector/pgvector:pg16' with hardcoded defaults:\n    - container name: 'thefactory-db'\n    - POSTGRES_USER='thefactory', POSTGRES_PASSWORD='thefactory', POSTGRES_DB='thefactorydb'\n    - hostPort=5435 mapped to container 5432\n    - If the container already exists and is running, return the same connection string. If it exists but is stopped, start it and return the same connection string. If it does not exist, create and start it.\n    - After readiness, call openDatabase() once to initialize schema, then close the pool. The function itself does not destroy the instance; it is intended for reuse across runs.\n\nAPI surface (minimal)\n- createDatabase(options?: { connectionString?: string; logLevel?: LogLevel }): Promise<{ client: TheFactoryDb; connectionString: string; destroy: () => Promise<void>; isManaged: boolean; dbName: string }>\n- destroyDatabase(handle): Promise<void>\n- createReusableDatabase(options?: { logLevel?: LogLevel }): Promise<{ connectionString: string; created: boolean }>\n- openDatabase(options) remains available for direct connections.\n\nBehavior & guarantees\n- Schema bootstrap: openDatabase() runs schema and hybrid search SQL so both modes are ready to use.\n- Readiness/health: managed mode waits for listening port and validates with SELECT 1.\n- Teardown: destroyDatabase() is idempotent and fully removes the instance/container or drops the temp database (external mode). No state persists for createDatabase().\n- Reusable provisioning: createReusableDatabase() is idempotent and never drops data; repeated calls return the same connection string.\n- No optional toggles on ephemeral flows: no container reuse, no isolation flags, no cleanup toggles.\n\nRequirements\n- Managed modes: Docker daemon available; image 'pgvector/pgvector:pg16'.\n- External mode: role must have CREATEDB privilege; pgvector 'vector' extension must be available/creatable. If not, initialization fails with a clear error.\n\nAcceptance\n- API exported from src/index.ts: createDatabase/destroyDatabase and createReusableDatabase alongside openDatabase().\n- Managed mode: spins up pgvector Postgres, client is usable, and container is torn down fully on destroy.\n- External mode: creates a new temporary database, initializes schema, and drops the database on destroy.\n- Reusable provisioning: first call creates a persistent container and returns a stable connection string; subsequent calls return the same connection string without altering data; schema is initialized automatically on first creation.\n- Documentation: README includes usage for ephemeral managed/external flows and the reusable database flow, with requirements and troubleshooting.\n- Tests: Lifecycle smoke tests cover both ephemeral modes and the reusable provisioning idempotency.",
  "features": [
    {
      "id": "84bd08a5-2422-4830-ae36-07167b5f46aa",
      "status": "+",
      "title": "Implement on-demand DB lifecycle (managed via Testcontainers, external fallback)",
      "description": "Implementation plan (definitive, no optional toggles)\n- Add dependency 'testcontainers' core. Use image 'pgvector/pgvector:pg16'.\n- Create 'src/runtime.ts' implementing:\n  - export type CreateDatabaseOptions = { connectionString?: string; logLevel?: LogLevel }\n  - export async function createDatabase(opts?: CreateDatabaseOptions): Promise<{ client: TheFactoryDb; connectionString: string; destroy: () => Promise<void>; isManaged: boolean; dbName: string }>\n    - Managed (no connectionString): start a fresh container with random POSTGRES_USER/PASSWORD/DB; map random host port; Wait.forListeningPorts(); verify readiness via 'SELECT 1'; build connection string; call openDatabase(). Register for process-exit cleanup.\n    - External (connectionString provided): parse server URL; connect to 'postgres' (or admin DB) to CREATE DATABASE tfdb_<random>; construct a URL pointing at the new DB; call openDatabase() on it. Ensure pgvector extension availability during init (relies on schema SQL creating extension).\n  - export async function destroyDatabase(handle): Promise<void>\n    - Always close the pool. If managed, stop and remove the container. If external, DROP DATABASE <dbName> (connect to admin DB); ensure idempotency if called multiple times.\n  - Ensure we never attempt to DROP the database we are currently connected to: switch connections appropriately for DROP.\n- Update 'src/index.ts' to export { createDatabase, destroyDatabase } while keeping openDatabase().\n- Security: use cryptographically strong random passwords; ephemeral ports.\n- Readiness: in addition to Testcontainers wait, perform a 'SELECT 1' using 'pg' to catch race conditions.\n- Global safety: process on SIGINT/SIGTERM triggers cleanup of any managed containers started in this process.",
      "context": [],
      "createdAt": "2025-10-16T22:24:53.414Z",
      "updatedAt": "2025-10-16T23:10:01.865Z",
      "completedAt": "2025-10-16T23:10:01.865Z"
    },
    {
      "id": "7389a86f-9f9d-40a1-a6d0-d8692b5de1fe",
      "status": "-",
      "title": "Documentation: on-demand lifecycle usage (managed and external)",
      "description": "Docs plan (including reusable provisioning)\n- Add README section 'On-demand database lifecycle' with three flows:\n  1) Ephemeral managed (default): code snippet using createDatabase() and destroyDatabase(); explains Docker requirement and that the instance is fully removed on destroy.\n  2) Ephemeral external: code snippet passing a server-level connectionString; explains a temporary database is created and dropped automatically; requires CREATEDB and pgvector availability.\n  3) Reusable database (managed persistent): code snippet using createReusableDatabase(); explains it creates (or reuses) a local container 'thefactory-db' on port 5435 with user/password 'thefactory' and database 'thefactorydb', initializes schema on first run, and returns the stable connection string for reuse.\n- Troubleshooting: Docker unavailable; port 5435 already in use; missing pgvector; insufficient privileges for external mode; how to list/stop the 'thefactory-db' container if needed.\n- Clarify that reusable provisioning is separate from the ephemeral lifecycle and intentionally persistent.\n- Document the minimal APIs and returned fields.\n",
      "context": [],
      "createdAt": "2025-10-16T22:24:53.416Z",
      "updatedAt": "2025-10-16T22:40:31.142Z"
    },
    {
      "id": "412a255b-83b3-4c2c-b57d-5d5b0da46513",
      "status": "-",
      "title": "Lifecycle tests: managed smoke test and external init",
      "description": "Lifecycle tests (including reusable provisioning)\n- tests/lifecycle/managed.smoke.test.ts (skip if Docker not available):\n  - const { client, destroy } = await createDatabase({ logLevel: 'error' })\n  - Insert a document and an entity, search, then destroy(); assert pool closed and container gone.\n- tests/lifecycle/external.smoke.test.ts (skip if no DATABASE_SERVER_URL):\n  - const { client, dbName, destroy } = await createDatabase({ connectionString: process.env.DATABASE_SERVER_URL!, logLevel: 'error' })\n  - Verify schema works; destroy(); confirm DB <dbName> dropped.\n- tests/lifecycle/reusable.smoke.test.ts (skip if Docker not available):\n  - const r1 = await createReusableDatabase({ logLevel: 'error' }); expect(r1.created).toBe(true) on first run (or allow false if container pre-exists in CI).\n  - const r2 = await createReusableDatabase({ logLevel: 'error' }); expect(r2.connectionString).toEqual(r1.connectionString); expect(r2.created).toBe(false).\n  - Connect via openDatabase({ connectionString: r1.connectionString }) and run a quick op to confirm schema exists.\n- Note: do not destroy the reusable container in tests; document manual cleanup instructions in README.\n",
      "context": [],
      "createdAt": "2025-10-16T22:24:53.418Z",
      "updatedAt": "2025-10-16T22:40:31.144Z"
    },
    {
      "id": "9f8f8e43-a014-49b4-95f3-7badb43825dc",
      "status": "-",
      "title": "Implement createReusableDatabase (managed persistent pgvector container)",
      "description": "- Add a new API: createReusableDatabase(options?: { logLevel?: LogLevel }): Promise<{ connectionString: string; created: boolean }>\n- Behavior:\n  - Use Docker to ensure a long-lived Postgres+pgvector container exists with deterministic configuration:\n    - image: 'pgvector/pgvector:pg16'\n    - container name: 'thefactory-db'\n    - env: POSTGRES_USER='thefactory', POSTGRES_PASSWORD='thefactory', POSTGRES_DB='thefactorydb'\n    - port mapping strategy: prefer host port 5435 -> container 5432; if 5435 is occupied, automatically fall back to the first free host port. Persist the chosen mapping (Docker keeps it), and always return the actual mapped port in the connection string.\n  - If the container exists and is running: inspect its port mapping and return 'postgresql://thefactory:thefactory@localhost:<hostPort>/thefactorydb' with created=false.\n  - If it exists but is stopped: start it, wait until ready (port + 'SELECT 1'), return the same connection string with created=false.\n  - If it does not exist: pull image if necessary, create and start the container with the port strategy above, wait until ready, then call openDatabase({ connectionString, logLevel }) to initialize schema and immediately close; return the connection string with created=true.\n- Implementation notes:\n  - Use Docker engine APIs (e.g., dockerode) to detect existing containers by name, read port bindings, and start/stop as needed. Avoid shelling out for portability.\n  - For finding a free port when 5435 is unavailable, use a reliable port-finder (e.g., get-port or portfinder) before container creation to request an explicit host binding.\n  - Idempotent and safe across multiple invocations; never drop data. Always return the exact connection string with the mapped host port.\n- Export from src/index.ts.\n- Add minimal unit/e2e tests covering:\n  - First call creates container (created=true) and returns a connection string.\n  - Second call returns same connection string (created=false).\n  - When 5435 is occupied, function still succeeds by selecting a different port and returns that port in the connection string.\n",
      "context": [],
      "createdAt": "2025-10-16T22:40:31.141Z",
      "updatedAt": "2025-10-16T22:45:01.974Z"
    }
  ],
  "featureIdToDisplayIndex": {
    "84bd08a5-2422-4830-ae36-07167b5f46aa": 1,
    "9f8f8e43-a014-49b4-95f3-7badb43825dc": 2,
    "7389a86f-9f9d-40a1-a6d0-d8692b5de1fe": 3,
    "412a255b-83b3-4c2c-b57d-5d5b0da46513": 4
  },
  "createdAt": "2025-10-05T21:39:57.524Z",
  "updatedAt": "2025-10-16T22:40:31.139Z"
}